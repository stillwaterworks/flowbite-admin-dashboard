{"cells":[{"cell_type":"code","source":["import pandas as pd\n","import numpy as np\n","import lightgbm as lgb\n","from sklearn.model_selection import train_test_split\n","from sklearn.metrics import mean_absolute_percentage_error\n","from datetime import date, timedelta\n","import random\n","\n","# --- 1. DATA SIMULATION ---\n","# In a real-world scenario, this section would be replaced with API calls\n","# to a POS system, weather service, and event calendars.\n","\n","def simulate_sales_data(days=365 * 2):\n","    \"\"\"\n","    Generates a realistic-looking sales dataset for a small business.\n","    \"\"\"\n","    print(f\"Simulating {days} days of sales data...\")\n","    start_date = date.today() - timedelta(days=days)\n","    dates = [start_date + timedelta(days=i) for i in range(days)]\n","\n","    products = {\n","        'Coffee': {'base_price': 3.50, 'base_units': 50, 'category': 'Beverage'},\n","        'Sandwich': {'base_price': 8.00, 'base_units': 30, 'category': 'Food'},\n","        'Pastry': {'base_price': 4.00, 'base_units': 40, 'category': 'Food'},\n","        'Branded Mug': {'base_price': 12.00, 'base_units': 5, 'category': 'Merchandise'}\n","    }\n","\n","    data = []\n","    for dt in dates:\n","        day_of_week = dt.weekday() # Monday=0, Sunday=6\n","\n","        # Simulate weekly seasonality\n","        if day_of_week in [5, 6]: # Weekend\n","            seasonality_factor = 1.4\n","        elif day_of_week == 0: # Monday\n","            seasonality_factor = 0.8\n","        else:\n","            seasonality_factor = 1.0\n","\n","        for name, props in products.items():\n","            # Add random noise\n","            noise = random.uniform(0.85, 1.15)\n","\n","            quantity_sold = int(props['base_units'] * seasonality_factor * noise)\n","            price = props['base_price']\n","\n","            data.append({\n","                'date': dt,\n","                'product_name': name,\n","                'category': props['category'],\n","                'quantity_sold': quantity_sold,\n","                'price_per_unit': price,\n","                'total_value': quantity_sold * price\n","            })\n","\n","    df = pd.DataFrame(data)\n","    df['date'] = pd.to_datetime(df['date'])\n","    print(\"...Simulation complete.\")\n","    return df\n","\n","def simulate_external_data(dates):\n","    \"\"\"\n","    Generates weather and local event data for a given date range.\n","    \"\"\"\n","    print(\"Simulating external weather and event data...\")\n","    external_data = []\n","    for dt in dates:\n","        # Simulate weather\n","        temp = 60 + np.sin(dt.month * 2 * np.pi / 12) * 20 + random.uniform(-5, 5)\n","        condition = random.choice(['Sunny', 'Cloudy', 'Rainy', 'Sunny'])\n","\n","        # Simulate local events (e.g., a street fair every ~90 days)\n","        is_event_nearby = True if (dt - dates[0]).days % 90 < 2 else False\n","\n","        external_data.append({\n","            'date': dt,\n","            'daily_high_temperature': round(temp, 1),\n","            'weather_condition': condition,\n","            'is_event_nearby': is_event_nearby\n","        })\n","    df = pd.DataFrame(external_data)\n","    df['date'] = pd.to_datetime(df['date'])\n","    print(\"...Simulation complete.\")\n","    return df\n","\n","# --- 2. FEATURE ENGINEERING ---\n","# This section creates the predictive features defined in the spec.\n","\n","def create_features(df):\n","    \"\"\"\n","    Engineers features for the model from the raw data.\n","    \"\"\"\n","    print(\"Engineering features...\")\n","    # Retain original product_name before one-hot encoding\n","    df['product_name_raw'] = df['product_name']\n","\n","    df['day_of_week'] = df['date'].dt.dayofweek\n","    df['month'] = df['date'].dt.month\n","    df['week_of_year'] = df['date'].dt.isocalendar().week.astype(int)\n","    df['is_weekend'] = df['day_of_week'].isin([5, 6]).astype(int)\n","\n","    # Create lag features (sales from the recent past)\n","    # We sort to ensure lags are calculated correctly\n","    df = df.sort_values(by=['product_name', 'date'])\n","    df['sales_lag_1_day'] = df.groupby('product_name')['quantity_sold'].shift(1)\n","    df['sales_lag_7_day'] = df.groupby('product_name')['quantity_sold'].shift(7)\n","\n","    # Create rolling average features\n","    df['sales_rolling_7_day_avg'] = df.groupby('product_name')['quantity_sold'].shift(1).rolling(window=7).mean()\n","\n","    # One-hot encode categorical features\n","    df = pd.get_dummies(df, columns=['weather_condition', 'product_name', 'category'], drop_first=True)\n","\n","    # Fill any NaNs created by lags/rolling averages\n","    df = df.fillna(0)\n","    print(\"...Feature engineering complete.\")\n","    return df\n","\n","# --- 3. MODEL TRAINING ---\n","\n","class SalesForecaster:\n","    def __init__(self, model_params=None):\n","        if model_params is None:\n","            self.model_params = {\n","                'objective': 'regression_l1', # L1 loss is Mean Absolute Error\n","                'metric': 'mape', # Mean Absolute Percentage Error\n","                'n_estimators': 1000,\n","                'learning_rate': 0.05,\n","                'feature_fraction': 0.8,\n","                'bagging_fraction': 0.8,\n","                'bagging_freq': 1,\n","                'verbose': -1,\n","                'n_jobs': -1,\n","                'seed': 42\n","            }\n","        self.model = lgb.LGBMRegressor(**self.model_params)\n","        self.trained_features = []\n","\n","    def train(self, df):\n","        \"\"\"\n","        Trains the LightGBM model on the feature-engineered data.\n","        \"\"\"\n","        print(\"Training the forecasting model...\")\n","\n","        # Define features (X) and target (y)\n","        self.target = 'quantity_sold'\n","        self.features = [col for col in df.columns if col not in ['date', self.target, 'price_per_unit', 'total_value', 'product_name_raw']]\n","\n","        X = df[self.features]\n","        y = df[self.target]\n","\n","        # Split data for validation\n","        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1, shuffle=False)\n","\n","        self.model.fit(X_train, y_train,\n","                       eval_set=[(X_test, y_test)],\n","                       eval_metric='mape',\n","                       callbacks=[lgb.early_stopping(100, verbose=False)])\n","\n","        # Evaluate model performance\n","        preds = self.model.predict(X_test)\n","        mape = mean_absolute_percentage_error(y_test, preds)\n","        print(f\"...Training complete. Model MAPE on test set: {mape:.2%}\")\n","\n","        # Store feature names for prediction\n","        self.trained_features = X_train.columns.tolist()\n","\n","    def predict_future(self, future_df):\n","        \"\"\"\n","        Makes predictions on a future-dated, feature-engineered dataframe.\n","        \"\"\"\n","        print(\"Generating future forecast...\")\n","        # Ensure future dataframe has the same columns as training data\n","        future_X = future_df[self.trained_features]\n","\n","        predictions = self.model.predict(future_X)\n","        future_df['forecasted_sales'] = np.round(predictions).astype(int)\n","        # Ensure forecast is not negative\n","        future_df['forecasted_sales'] = future_df['forecasted_sales'].clip(lower=0)\n","\n","        return future_df\n","\n","# --- 4. DECISION SUPPORT & APPLICATION ---\n","\n","def generate_purchase_recommendation(forecast_df, current_inventory):\n","    \"\"\"\n","    Generates a simple purchase order based on the forecast.\n","    \"\"\"\n","    print(\"\\n--- Automated Purchasing Report ---\")\n","    recommendations = []\n","    for _, row in forecast_df.iterrows():\n","        product = row['product_name_raw']\n","        forecast = row['forecasted_sales']\n","        on_hand = current_inventory.get(product, 0)\n","\n","        needed = forecast - on_hand\n","        if needed > 0:\n","            print(f\"Product: {product}\")\n","            print(f\"  > Forecasted Sales: {forecast} units\")\n","            print(f\"  > Currently On Hand: {on_hand} units\")\n","            print(f\"  > RECOMMENDATION: Purchase at least {needed} units.\")\n","            recommendations.append({'product': product, 'purchase_qty': needed})\n","    return recommendations\n","\n","def run_event_roi_calculator(event_name, costs, opportunity_cost, brand_lift):\n","    \"\"\"\n","    Runs the Event ROI analysis as defined in the spec.\n","    \"\"\"\n","    print(f\"\\n--- Event ROI Calculator: '{event_name}' ---\")\n","    projected_profit = costs['projected_sales'] - (costs['inventory'] + costs['staff'] + costs['fee'])\n","    net_financial = projected_profit - opportunity_cost\n","\n","    print(f\"Projected Event Profit: ${projected_profit:,.2f}\")\n","    print(f\"Opportunity Cost (Lost Sales at Store): ${opportunity_cost:,.2f}\")\n","    print(f\"Projected Brand Lift (Followers): {brand_lift:.0%}\")\n","    print(\"-\" * 20)\n","    print(f\"Net Financial Impact: ${net_financial:,.2f}\")\n","\n","    if net_financial < 0:\n","        print(f\"Conclusion: The event represents a net financial loss of ${abs(net_financial):,.2f} but offers a significant brand visibility boost.\")\n","    else:\n","        print(\"Conclusion: The event is projected to be financially positive and offers a brand visibility boost.\")\n","\n","# --- MAIN EXECUTION ---\n","if __name__ == '__main__':\n","    # 1. Simulate Data\n","    sales_df = simulate_sales_data()\n","    unique_dates = sales_df['date'].unique()\n","    external_df = simulate_external_data(unique_dates)\n","\n","    # Merge data sources\n","    full_df = pd.merge(sales_df, external_df, on='date')\n","\n","    # 2. Engineer Features\n","    featured_df = create_features(full_df.copy())\n","\n","    # 3. Train Model\n","    forecaster = SalesForecaster()\n","    forecaster.train(featured_df)\n","\n","    # 4. Application: Generate a forecast for tomorrow\n","    # Create a dataframe for tomorrow's date\n","    tomorrow = date.today() + timedelta(days=1)\n","    # Use 'product_name_raw' which is retained in create_features\n","    products = featured_df['product_name_raw'].unique()\n","\n","    # This part is complex: to predict for tomorrow, we need its features,\n","    # including lag features from today. For this prototype, we'll use the\n","    # last available day's data to create a simplified future dataframe.\n","    last_day_data = featured_df[featured_df['date'] == featured_df['date'].max()].copy()\n","\n","    # Create future data for prediction by copying the last day's data\n","    # and updating the date and external features for tomorrow.\n","    future_data_for_prediction = last_day_data.copy()\n","    future_data_for_prediction['date'] = pd.to_datetime(tomorrow)\n","\n","    # Simulate tomorrow's weather and event data\n","    tomorrow_external_data = simulate_external_data([tomorrow]).iloc[0]\n","\n","    # Update the external features in the future data for prediction\n","    # Need to handle the one-hot encoded weather columns dynamically\n","    weather_conditions = ['Sunny', 'Cloudy', 'Rainy'] # Assuming these are the possible conditions\n","\n","    for condition in weather_conditions:\n","        col_name = f'weather_condition_{condition}'\n","        if col_name in future_data_for_prediction.columns:\n","            future_data_for_prediction[col_name] = 1 if tomorrow_external_data['weather_condition'] == condition else 0\n","\n","    future_data_for_prediction['daily_high_temperature'] = tomorrow_external_data['daily_high_temperature']\n","    future_data_for_prediction['is_event_nearby'] = tomorrow_external_data['is_event_nearby']\n","\n","    # Re-calculate date-related features for tomorrow\n","    future_data_for_prediction['day_of_week'] = future_data_for_prediction['date'].dt.dayofweek\n","    future_data_for_prediction['month'] = future_data_for_prediction['date'].dt.month\n","    future_data_for_prediction['week_of_year'] = future_data_for_prediction['date'].dt.isocalendar().week.astype(int)\n","    future_data_for_prediction['is_weekend'] = future_data_for_prediction['day_of_week'].isin([5, 6]).astype(int)\n","\n","\n","    # Make prediction\n","    forecast_results = forecaster.predict_future(future_data_for_prediction)\n","\n","    print(\"\\n--- Sales Forecast for Tomorrow ---\")\n","    print(forecast_results[['product_name_raw', 'forecasted_sales']])\n","\n","    # Run Decision Support Tools\n","    current_inventory = {'Coffee': 20, 'Sandwich': 10, 'Pastry': 15, 'Branded Mug': 3}\n","    generate_purchase_recommendation(forecast_results, current_inventory)\n","\n","    event_costs = {'projected_sales': 1200, 'inventory': 300, 'staff': 400, 'fee': 100}\n","    run_event_roi_calculator(\n","        event_name=\"Dallas Summerfest\",\n","        costs=event_costs,\n","        opportunity_cost=500,\n","        brand_lift=0.08\n","    )"],"outputs":[{"output_type":"stream","name":"stdout","text":["Simulating 730 days of sales data...\n","...Simulation complete.\n","Simulating external weather and event data...\n","...Simulation complete.\n","Engineering features...\n","...Feature engineering complete.\n","Training the forecasting model...\n","...Training complete. Model MAPE on test set: 8.35%\n","Simulating external weather and event data...\n","...Simulation complete.\n","Generating future forecast...\n","\n","--- Sales Forecast for Tomorrow ---\n","     product_name_raw  forecasted_sales\n","2919      Branded Mug                 6\n","2916           Coffee                58\n","2918           Pastry                48\n","2917         Sandwich                37\n","\n","--- Automated Purchasing Report ---\n","Product: Branded Mug\n","  > Forecasted Sales: 6 units\n","  > Currently On Hand: 3 units\n","  > RECOMMENDATION: Purchase at least 3 units.\n","Product: Coffee\n","  > Forecasted Sales: 58 units\n","  > Currently On Hand: 20 units\n","  > RECOMMENDATION: Purchase at least 38 units.\n","Product: Pastry\n","  > Forecasted Sales: 48 units\n","  > Currently On Hand: 15 units\n","  > RECOMMENDATION: Purchase at least 33 units.\n","Product: Sandwich\n","  > Forecasted Sales: 37 units\n","  > Currently On Hand: 10 units\n","  > RECOMMENDATION: Purchase at least 27 units.\n","\n","--- Event ROI Calculator: 'Dallas Summerfest' ---\n","Projected Event Profit: $400.00\n","Opportunity Cost (Lost Sales at Store): $500.00\n","Projected Brand Lift (Followers): 8%\n","--------------------\n","Net Financial Impact: $-100.00\n","Conclusion: The event represents a net financial loss of $100.00 but offers a significant brand visibility boost.\n"]}],"execution_count":8,"metadata":{"colab":{"base_uri":"https://localhost:8080/"},"id":"UL6EVy7hh7XS","executionInfo":{"status":"ok","timestamp":1754336444483,"user_tz":420,"elapsed":367,"user":{"displayName":"Ricky C","userId":"15194511868682273803"}},"outputId":"b2492693-2cbf-4ea7-95e3-c1f2182c8412"}}],"metadata":{"colab":{"provenance":[]},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}